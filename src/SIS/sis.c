#include "sis.h"
#include "../bmp/bmp.h"
#include "../globals.h"
#include "../utils/utils.h"
#include <assert.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// TODO: remove this... Won't be necessary when steganography.
Color colors[256] = {
  {0x00, 0x00, 0x00, 0x00}, {0x01, 0x01, 0x01, 0x00}, {0x02, 0x02, 0x02, 0x00}, {0x03, 0x03, 0x03, 0x00},
  {0x04, 0x04, 0x04, 0x00}, {0x05, 0x05, 0x05, 0x00}, {0x06, 0x06, 0x06, 0x00}, {0x07, 0x07, 0x07, 0x00},
  {0x08, 0x08, 0x08, 0x00}, {0x09, 0x09, 0x09, 0x00}, {0x0a, 0x0a, 0x0a, 0x00}, {0x0b, 0x0b, 0x0b, 0x00},
  {0x0c, 0x0c, 0x0c, 0x00}, {0x0d, 0x0d, 0x0d, 0x00}, {0x0e, 0x0e, 0x0e, 0x00}, {0x0f, 0x0f, 0x0f, 0x00},
  {0x10, 0x10, 0x10, 0x00}, {0x11, 0x11, 0x11, 0x00}, {0x12, 0x12, 0x12, 0x00}, {0x13, 0x13, 0x13, 0x00},
  {0x14, 0x14, 0x14, 0x00}, {0x15, 0x15, 0x15, 0x00}, {0x16, 0x16, 0x16, 0x00}, {0x17, 0x17, 0x17, 0x00},
  {0x18, 0x18, 0x18, 0x00}, {0x19, 0x19, 0x19, 0x00}, {0x1a, 0x1a, 0x1a, 0x00}, {0x1b, 0x1b, 0x1b, 0x00},
  {0x1c, 0x1c, 0x1c, 0x00}, {0x1d, 0x1d, 0x1d, 0x00}, {0x1e, 0x1e, 0x1e, 0x00}, {0x1f, 0x1f, 0x1f, 0x00},
  {0x20, 0x20, 0x20, 0x00}, {0x21, 0x21, 0x21, 0x00}, {0x22, 0x22, 0x22, 0x00}, {0x23, 0x23, 0x23, 0x00},
  {0x24, 0x24, 0x24, 0x00}, {0x25, 0x25, 0x25, 0x00}, {0x26, 0x26, 0x26, 0x00}, {0x27, 0x27, 0x27, 0x00},
  {0x28, 0x28, 0x28, 0x00}, {0x29, 0x29, 0x29, 0x00}, {0x2a, 0x2a, 0x2a, 0x00}, {0x2b, 0x2b, 0x2b, 0x00},
  {0x2c, 0x2c, 0x2c, 0x00}, {0x2d, 0x2d, 0x2d, 0x00}, {0x2e, 0x2e, 0x2e, 0x00}, {0x2f, 0x2f, 0x2f, 0x00},
  {0x30, 0x30, 0x30, 0x00}, {0x31, 0x31, 0x31, 0x00}, {0x32, 0x32, 0x32, 0x00}, {0x33, 0x33, 0x33, 0x00},
  {0x34, 0x34, 0x34, 0x00}, {0x35, 0x35, 0x35, 0x00}, {0x36, 0x36, 0x36, 0x00}, {0x37, 0x37, 0x37, 0x00},
  {0x38, 0x38, 0x38, 0x00}, {0x39, 0x39, 0x39, 0x00}, {0x3a, 0x3a, 0x3a, 0x00}, {0x3b, 0x3b, 0x3b, 0x00},
  {0x3c, 0x3c, 0x3c, 0x00}, {0x3d, 0x3d, 0x3d, 0x00}, {0x3e, 0x3e, 0x3e, 0x00}, {0x3f, 0x3f, 0x3f, 0x00},
  {0x40, 0x40, 0x40, 0x00}, {0x41, 0x41, 0x41, 0x00}, {0x42, 0x42, 0x42, 0x00}, {0x43, 0x43, 0x43, 0x00},
  {0x44, 0x44, 0x44, 0x00}, {0x45, 0x45, 0x45, 0x00}, {0x46, 0x46, 0x46, 0x00}, {0x47, 0x47, 0x47, 0x00},
  {0x48, 0x48, 0x48, 0x00}, {0x49, 0x49, 0x49, 0x00}, {0x4a, 0x4a, 0x4a, 0x00}, {0x4b, 0x4b, 0x4b, 0x00},
  {0x4c, 0x4c, 0x4c, 0x00}, {0x4d, 0x4d, 0x4d, 0x00}, {0x4e, 0x4e, 0x4e, 0x00}, {0x4f, 0x4f, 0x4f, 0x00},
  {0x50, 0x50, 0x50, 0x00}, {0x51, 0x51, 0x51, 0x00}, {0x52, 0x52, 0x52, 0x00}, {0x53, 0x53, 0x53, 0x00},
  {0x54, 0x54, 0x54, 0x00}, {0x55, 0x55, 0x55, 0x00}, {0x56, 0x56, 0x56, 0x00}, {0x57, 0x57, 0x57, 0x00},
  {0x58, 0x58, 0x58, 0x00}, {0x59, 0x59, 0x59, 0x00}, {0x5a, 0x5a, 0x5a, 0x00}, {0x5b, 0x5b, 0x5b, 0x00},
  {0x5c, 0x5c, 0x5c, 0x00}, {0x5d, 0x5d, 0x5d, 0x00}, {0x5e, 0x5e, 0x5e, 0x00}, {0x5f, 0x5f, 0x5f, 0x00},
  {0x60, 0x60, 0x60, 0x00}, {0x61, 0x61, 0x61, 0x00}, {0x62, 0x62, 0x62, 0x00}, {0x63, 0x63, 0x63, 0x00},
  {0x64, 0x64, 0x64, 0x00}, {0x65, 0x65, 0x65, 0x00}, {0x66, 0x66, 0x66, 0x00}, {0x67, 0x67, 0x67, 0x00},
  {0x68, 0x68, 0x68, 0x00}, {0x69, 0x69, 0x69, 0x00}, {0x6a, 0x6a, 0x6a, 0x00}, {0x6b, 0x6b, 0x6b, 0x00},
  {0x6c, 0x6c, 0x6c, 0x00}, {0x6d, 0x6d, 0x6d, 0x00}, {0x6e, 0x6e, 0x6e, 0x00}, {0x6f, 0x6f, 0x6f, 0x00},
  {0x70, 0x70, 0x70, 0x00}, {0x71, 0x71, 0x71, 0x00}, {0x72, 0x72, 0x72, 0x00}, {0x73, 0x73, 0x73, 0x00},
  {0x74, 0x74, 0x74, 0x00}, {0x75, 0x75, 0x75, 0x00}, {0x76, 0x76, 0x76, 0x00}, {0x77, 0x77, 0x77, 0x00},
  {0x78, 0x78, 0x78, 0x00}, {0x79, 0x79, 0x79, 0x00}, {0x7a, 0x7a, 0x7a, 0x00}, {0x7b, 0x7b, 0x7b, 0x00},
  {0x7c, 0x7c, 0x7c, 0x00}, {0x7d, 0x7d, 0x7d, 0x00}, {0x7e, 0x7e, 0x7e, 0x00}, {0x7f, 0x7f, 0x7f, 0x00},
  {0x80, 0x80, 0x80, 0x00}, {0x81, 0x81, 0x81, 0x00}, {0x82, 0x82, 0x82, 0x00}, {0x83, 0x83, 0x83, 0x00},
  {0x84, 0x84, 0x84, 0x00}, {0x85, 0x85, 0x85, 0x00}, {0x86, 0x86, 0x86, 0x00}, {0x87, 0x87, 0x87, 0x00},
  {0x88, 0x88, 0x88, 0x00}, {0x89, 0x89, 0x89, 0x00}, {0x8a, 0x8a, 0x8a, 0x00}, {0x8b, 0x8b, 0x8b, 0x00},
  {0x8c, 0x8c, 0x8c, 0x00}, {0x8d, 0x8d, 0x8d, 0x00}, {0x8e, 0x8e, 0x8e, 0x00}, {0x8f, 0x8f, 0x8f, 0x00},
  {0x90, 0x90, 0x90, 0x00}, {0x91, 0x91, 0x91, 0x00}, {0x92, 0x92, 0x92, 0x00}, {0x93, 0x93, 0x93, 0x00},
  {0x94, 0x94, 0x94, 0x00}, {0x95, 0x95, 0x95, 0x00}, {0x96, 0x96, 0x96, 0x00}, {0x97, 0x97, 0x97, 0x00},
  {0x98, 0x98, 0x98, 0x00}, {0x99, 0x99, 0x99, 0x00}, {0x9a, 0x9a, 0x9a, 0x00}, {0x9b, 0x9b, 0x9b, 0x00},
  {0x9c, 0x9c, 0x9c, 0x00}, {0x9d, 0x9d, 0x9d, 0x00}, {0x9e, 0x9e, 0x9e, 0x00}, {0x9f, 0x9f, 0x9f, 0x00},
  {0xa0, 0xa0, 0xa0, 0x00}, {0xa1, 0xa1, 0xa1, 0x00}, {0xa2, 0xa2, 0xa2, 0x00}, {0xa3, 0xa3, 0xa3, 0x00},
  {0xa4, 0xa4, 0xa4, 0x00}, {0xa5, 0xa5, 0xa5, 0x00}, {0xa6, 0xa6, 0xa6, 0x00}, {0xa7, 0xa7, 0xa7, 0x00},
  {0xa8, 0xa8, 0xa8, 0x00}, {0xa9, 0xa9, 0xa9, 0x00}, {0xaa, 0xaa, 0xaa, 0x00}, {0xab, 0xab, 0xab, 0x00},
  {0xac, 0xac, 0xac, 0x00}, {0xad, 0xad, 0xad, 0x00}, {0xae, 0xae, 0xae, 0x00}, {0xaf, 0xaf, 0xaf, 0x00},
  {0xb0, 0xb0, 0xb0, 0x00}, {0xb1, 0xb1, 0xb1, 0x00}, {0xb2, 0xb2, 0xb2, 0x00}, {0xb3, 0xb3, 0xb3, 0x00},
  {0xb4, 0xb4, 0xb4, 0x00}, {0xb5, 0xb5, 0xb5, 0x00}, {0xb6, 0xb6, 0xb6, 0x00}, {0xb7, 0xb7, 0xb7, 0x00},
  {0xb8, 0xb8, 0xb8, 0x00}, {0xb9, 0xb9, 0xb9, 0x00}, {0xba, 0xba, 0xba, 0x00}, {0xbb, 0xbb, 0xbb, 0x00},
  {0xbc, 0xbc, 0xbc, 0x00}, {0xbd, 0xbd, 0xbd, 0x00}, {0xbe, 0xbe, 0xbe, 0x00}, {0xbf, 0xbf, 0xbf, 0x00},
  {0xc0, 0xc0, 0xc0, 0x00}, {0xc1, 0xc1, 0xc1, 0x00}, {0xc2, 0xc2, 0xc2, 0x00}, {0xc3, 0xc3, 0xc3, 0x00},
  {0xc4, 0xc4, 0xc4, 0x00}, {0xc5, 0xc5, 0xc5, 0x00}, {0xc6, 0xc6, 0xc6, 0x00}, {0xc7, 0xc7, 0xc7, 0x00},
  {0xc8, 0xc8, 0xc8, 0x00}, {0xc9, 0xc9, 0xc9, 0x00}, {0xca, 0xca, 0xca, 0x00}, {0xcb, 0xcb, 0xcb, 0x00},
  {0xcc, 0xcc, 0xcc, 0x00}, {0xcd, 0xcd, 0xcd, 0x00}, {0xce, 0xce, 0xce, 0x00}, {0xcf, 0xcf, 0xcf, 0x00},
  {0xd0, 0xd0, 0xd0, 0x00}, {0xd1, 0xd1, 0xd1, 0x00}, {0xd2, 0xd2, 0xd2, 0x00}, {0xd3, 0xd3, 0xd3, 0x00},
  {0xd4, 0xd4, 0xd4, 0x00}, {0xd5, 0xd5, 0xd5, 0x00}, {0xd6, 0xd6, 0xd6, 0x00}, {0xd7, 0xd7, 0xd7, 0x00},
  {0xd8, 0xd8, 0xd8, 0x00}, {0xd9, 0xd9, 0xd9, 0x00}, {0xda, 0xda, 0xda, 0x00}, {0xdb, 0xdb, 0xdb, 0x00},
  {0xdc, 0xdc, 0xdc, 0x00}, {0xdd, 0xdd, 0xdd, 0x00}, {0xde, 0xde, 0xde, 0x00}, {0xdf, 0xdf, 0xdf, 0x00},
  {0xe0, 0xe0, 0xe0, 0x00}, {0xe1, 0xe1, 0xe1, 0x00}, {0xe2, 0xe2, 0xe2, 0x00}, {0xe3, 0xe3, 0xe3, 0x00},
  {0xe4, 0xe4, 0xe4, 0x00}, {0xe5, 0xe5, 0xe5, 0x00}, {0xe6, 0xe6, 0xe6, 0x00}, {0xe7, 0xe7, 0xe7, 0x00},
  {0xe8, 0xe8, 0xe8, 0x00}, {0xe9, 0xe9, 0xe9, 0x00}, {0xea, 0xea, 0xea, 0x00}, {0xeb, 0xeb, 0xeb, 0x00},
  {0xec, 0xec, 0xec, 0x00}, {0xed, 0xed, 0xed, 0x00}, {0xee, 0xee, 0xee, 0x00}, {0xef, 0xef, 0xef, 0x00},
  {0xf0, 0xf0, 0xf0, 0x00}, {0xf1, 0xf1, 0xf1, 0x00}, {0xf2, 0xf2, 0xf2, 0x00}, {0xf3, 0xf3, 0xf3, 0x00},
  {0xf4, 0xf4, 0xf4, 0x00}, {0xf5, 0xf5, 0xf5, 0x00}, {0xf6, 0xf6, 0xf6, 0x00}, {0xf7, 0xf7, 0xf7, 0x00},
  {0xf8, 0xf8, 0xf8, 0x00}, {0xf9, 0xf9, 0xf9, 0x00}, {0xfa, 0xfa, 0xfa, 0x00}, {0xfb, 0xfb, 0xfb, 0x00},
  {0xfc, 0xfc, 0xfc, 0x00}, {0xfd, 0xfd, 0xfd, 0x00}, {0xfe, 0xfe, 0xfe, 0x00}, {0xff, 0xff, 0xff, 0x00},
};

void calculateShadowPixel(uint8_t min_shadows, uint8_t coefficients[], uint8_t tot_shadows, uint32_t pixels[]);
void assignShadowPixels(
  uint32_t shadow_pixel_idx, uint8_t* coefficients, uint8_t min_shadows, uint8_t tot_shadows, BMP shadows[]
);

void sisShadows(BMP bmp, uint8_t min_shadows, uint8_t tot_shadows, BMP shadows[tot_shadows]) {
  assert(min_shadows >= 2 && tot_shadows >= min_shadows);
  const uint8_t* img = bmpImage(bmp);
  uint32_t img_size = bmpImageSize(bmp);

  // TODO: handle seed properly...
  uint32_t seed = 0x1234;
  uint8_t seed_low = seed & 0xFFu;
  uint8_t seed_high = (seed >> 8u) & 0xFFu;
  //

  uint32_t shadow_size = ceilDiv(img_size, min_shadows);
  uint32_t shadow_rows, shadow_cols;
  closestDivisors(shadow_size, &shadow_rows, &shadow_cols);

  for (uint8_t i = 0; i < tot_shadows; ++i) {
    shadows[i] = bmpNew(
      shadow_cols, shadow_rows, 8, (uint8_t[]){seed_low, seed_high, i + 1, 0}, 256, colors, sizeof(uint32_t) * 3,
      (uint8_t*)(uint32_t[]){bmpWidth(bmp), bmpHeight(bmp), bmpBpp(bmp)}
    );
  }

  uint8_t coefficients[min_shadows];
  uint32_t i;
  for (i = 0; i < img_size / min_shadows; ++i) {
    for (int j = 0; j < min_shadows; ++j) coefficients[j] = img[(i * min_shadows) + j];
    assignShadowPixels(i, coefficients, min_shadows, tot_shadows, shadows);
  }

  // If img_size not multiple of r then use last img_size%r pixels, pad with
  // zeros and calculate a new shadow pixel.
  if (img_size % min_shadows != 0) {
    int j;
    for (i = i * min_shadows, j = 0; i < img_size; ++i, ++j) coefficients[j] = img[i];
    while (j < min_shadows) coefficients[j++] = 0;
    assignShadowPixels(shadow_size - 1, coefficients, min_shadows, tot_shadows, shadows);
  }
}

BMP sisRecover(uint8_t min_shadows, BMP shadows[min_shadows]) {
  uint32_t extra_data_size = bmpExtraSize(shadows[0]);
  if (extra_data_size < 3 * sizeof(uint32_t)) {
    fprintf(stderr, "Incorrect shadow format. Missing secret image info.");
    exit(1);
  }
  // uint32_t shadow_width = bmpWidth(shadows[0]);
  // uint32_t shadow_height = bmpHeight(shadows[0]);
  uint16_t* reserved;
  uint16_t shadows_x[min_shadows];
  for (uint32_t i = 0; i < min_shadows; ++i) {
    reserved = (uint16_t*)bmpReserved(shadows[i]);
    shadows_x[i] = reserved[1];
  }
  // uint16_t seed = reserved[0];

  uint32_t* secret_info = (uint32_t*)bmpExtraData(shadows[0]);
  uint32_t secret_width = secret_info[0];
  uint32_t secret_height = secret_info[1];
  uint32_t secret_bpp = secret_info[2];
  uint32_t n_colors = secret_bpp > 8 ? 0 : 256;
  BMP secret = bmpNew(secret_width, secret_height, secret_bpp, NULL, n_colors, n_colors == 0 ? NULL : colors, 0, NULL);
  uint8_t* img = bmpImage(secret);
  uint32_t img_size = bmpImageSize(secret);
  uint32_t shadow_size = bmpImageSize(shadows[0]);
  uint32_t img_idx = 0;
  for (uint32_t k = 0; k < shadow_size; ++k) {
    uint32_t ec_system[min_shadows][min_shadows + 1];
    for (int i = 0; i < min_shadows; ++i) {
      uint32_t x_pow = 1;
      for (int j = 0; j < min_shadows; ++j) {
        ec_system[i][j] = x_pow;
        x_pow = (x_pow * shadows_x[i]) % MOD;
      }
      ec_system[i][min_shadows] = bmpImage(shadows[i])[k];
    }
    uint8_t coefs[min_shadows];
    solveSystem(min_shadows, min_shadows + 1, ec_system[0], coefs);
    for (int i = 0; i < min_shadows && img_idx < img_size; ++i, ++img_idx) {
      img[img_idx] = coefs[i];
    }
  }

  return secret;
}

/*
   Img 5x3 con SIS (4,5). Un pixel de padding para d en 0

   a a a
   a b b      s1     s2     s3     s4    s5
   b b c ==> abcd   abcd   abcd   abcd  abcd
   c c c
   d d d

                i != j != k != l
   a_0 + a_1 * i + a_2 * i^2 + a_3 * i^3 = a_si
   a_0 + a_1 * j + a_2 * j^2 + a_3 * j^3 = a_sj
   a_0 + a_1 * k + a_2 * k^2 + a_3 * k^3 = a_sk
   a_0 + a_1 * l + a_2 * l^2 + a_3 * l^3 = a_sl

   b_0 + b_1 * i + b_2 * i^2 + b_3 * i^3 = b_si
   b_0 + b_1 * j + b_2 * j^2 + b_3 * j^3 = b_sj
   b_0 + b_1 * k + b_2 * k^2 + b_3 * k^3 = b_sk
   b_0 + b_1 * l + b_2 * l^2 + b_3 * l^3 = b_sl

   c_0 + c_1 * i + c_2 * i^2 + c_3 * i^3 = c_si
   c_0 + c_1 * j + c_2 * j^2 + c_3 * j^3 = c_sj
   c_0 + c_1 * k + c_2 * k^2 + c_3 * k^3 = c_sk
   c_0 + c_1 * l + c_2 * l^2 + c_3 * l^3 = c_sl

   d_0 + d_1 * i + d_2 * i^2 +   0 * i^3 = d_si
   d_0 + d_1 * j + d_2 * j^2 +   0 * j^3 = d_sj
   d_0 + d_1 * k + d_2 * k^2 +   0 * k^3 = d_sk
   d_0 + d_1 * l + d_2 * l^2 +   0 * l^3 = d_sl
*/

// Internal functions

void calculateShadowPixel(uint8_t min_shadows, uint8_t coefficients[], uint8_t tot_shadows, uint32_t pixels[]) {
  bool recalculate;
  do {
    recalculate = false;
    for (int i = 0; i < tot_shadows; ++i) pixels[i] = polynomialModuloEval(min_shadows - 1, coefficients, i + 1);
    for (int i = 0; i < tot_shadows; ++i) {
      if (pixels[i] == 256) {
        int j = 0;
        while (j < min_shadows && coefficients[j] == 0) ++j;
        assert(j < min_shadows && "Expected at least one non-zero coefficient");
        --coefficients[j];
        recalculate = true;
        break;
      }
    }
  } while (recalculate);
}

void assignShadowPixels(
  uint32_t shadow_pixel_idx, uint8_t* coefficients, uint8_t min_shadows, uint8_t tot_shadows, BMP shadows[]
) {
  uint32_t pixels[tot_shadows];
  calculateShadowPixel(min_shadows, coefficients, tot_shadows, pixels);
  for (int j = 0; j < tot_shadows; ++j) bmpImage(shadows[j])[shadow_pixel_idx] = pixels[j];
}
